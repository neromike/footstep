<!DOCTYPE html>
<html>
<head>
	<meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1.0" />
	<meta name="apple-mobile-web-app-capable" content="yes" />
	<title>Footsteps</title>
</head>

<style>
* {
	padding: 0px;
	margin: 0px;
	user-select: none;
}
body {
	overflow: hidden;
}
.hidden_img {
	display: none;
}
#myCanvas {
	margin: auto;
	position:  absolute;
	top: 0px;
	left: 0px;
}
</style>

<body>
<img id="background_img" class="hidden_img" src="parchment.jpg" />
<img id="footprint_R" class="hidden_img" src="footprint_R.png" />
<img id="footprint_L" class="hidden_img" src="footprint_L.png" />
<canvas id="myCanvas"></canvas>
</body>

<script>
const canvas = document.getElementById('myCanvas')
const context = canvas.getContext('2d')
canvas.width = window.innerWidth
canvas.height = window.innerHeight
var background_img = document.getElementById("background_img")
var footprint_R_img = document.getElementById("footprint_R")
var footprint_L_img = document.getElementById("footprint_L")

document.addEventListener('mousedown', setPosition)
document.addEventListener('mousemove', setPosition)
document.addEventListener('mouseup', setPosition)
document.addEventListener('touchstart', setPosition)
document.addEventListener('touchmove', setPosition)
document.addEventListener('touchend', setPosition)
var button_down = false
var new_x
var new_y
function setPosition(e) {
	if (e.type == "mousedown" || e.type == "touchstart") {
		button_down = true
	} else if (e.type == "mouseup" || e.type == "touchend") {
		button_down = false
	}
	
	if (button_down) {
		if (e.type == "touchstart" || e.type == "touchmove" || e.type == "touchend") {
			new_x = e.touches[0].clientX
			new_y = e.touches[0].clientY
		} else if (e.type == "mousedown" || e.type == "mousemove" || e.type == "mouseup"){
			new_x = e.clientX
			new_y = e.clientY
		}
	}
}

var player_list = []
var player = {
	x: 100,
	y: 100,
	angle: 0,
	max_angle_change: (Math.PI / 2) / 9,
	min_angle_change: 5 * (Math.PI / 2) / 90,
	footprint_width: 10,
	footprint_length: 25,
	speed: 2,
	footprint_log: [],
	last_footprint: 'L',
	last_x_drawn: -100,
	last_y_drawn: -100,
	stride: 25,
	max_footprints: 5,
	footprint_decay: 1000,
	draw_line: function() {
		// draw a line from the player's position pointing 30 pixels in the direction they are facing
		context.beginPath()
		context.strokeStyle = 'green'
		context.moveTo(this.x, this.y)
		context.lineTo(this.x + 30 * Math.cos(this.angle), this.y + 30 * Math.sin(this.angle))
		context.stroke()
	},
	draw_foot: function () {
		// set the coordinates and images for the side being drawn
		if (this.last_footprint == 'R') {
			this_x = this.x + this.footprint_width * Math.sin(Math.PI - this.angle)
			this_y = this.y + this.footprint_width * Math.cos(Math.PI - this.angle)
			this_img = footprint_L_img
			this.last_footprint = 'L'
		} else {
			this_x = this.x - this.footprint_width * Math.sin(Math.PI - this.angle)
			this_y = this.y - this.footprint_width * Math.cos(Math.PI - this.angle)
			this_img = footprint_R_img
			this.last_footprint = 'R'
		}
		
		// add the footprint to the log
		player.footprint_log.push({
			x: this_x,
			y: this_y,
			angle: this.angle,
			image: this_img,
			image_width: this.footprint_width,
			image_height: this.footprint_length,
			alpha: 1.0,
			timestamp: Date.now()
		})
	}
}

function draw_image(x, y, angle, image, image_width, image_height, alpha) {
	// Draw an image at a given position and angle
	context.save()
	context.translate(x, y)
	context.rotate((90 * Math.PI / 180) + angle)
	context.globalAlpha = alpha
	context.drawImage(image, - image_width / 2, - image_height / 2, image_width, image_height)
	context.restore()
}

function getDistance(x1, y1, x2, y2){ return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)); }

function update() {
	if (button_down) {
		new_angle = Math.atan2(new_y - player.y, new_x - player.x)
		old_angle = player.angle

		// fixes quadrant issue
		if ((old_angle <= -Math.PI/2) && (new_angle >= Math.PI/2)) {
			old_angle += Math.PI * 2
		}
		if ((old_angle >= Math.PI/2) && (new_angle <= -Math.PI/2)) {
			old_angle -= Math.PI * 2
		}

		// updates the player angle
		if (new_angle < old_angle) {
			if ((old_angle - new_angle) > player.max_angle_change) {
				player.angle -= player.max_angle_change
			} else {
				player.angle -= new_angle - old_angle
			}
		} else if (new_angle > old_angle) {
			if ((new_angle - old_angle) > player.max_angle_change) {
				player.angle += player.max_angle_change
			} else {
				player.angle += new_angle - old_angle
			}
		}

		// get rid of wooble, no minor angle changes
		if (Math.abs(old_angle - new_angle) <= player.min_angle_change) {
			player.angle = old_angle
		}

		// normalize the player angle: -pi to pi
		if (player.angle < -Math.PI) {
			player.angle += 2 * Math.PI
		}
		if (player.angle > Math.PI) {
			player.angle -= 2 * Math.PI
		}
		
		distance = getDistance(player.x, player.y, new_x, new_y)
		if (distance > player.footprint_length * 2) {

			if (distance > player.speed) {
				distance = player.speed
			}

			player.x += Math.cos(player.angle) * distance
			player.y += Math.sin(player.angle) * distance
		}
		
	}
	
	// remove old footprints and transparencies of existing foorptints in log
	for (let i=0; i<player.footprint_log.length; i++) {
		let time_diff = Date.now() - player.footprint_log[i].timestamp
		
		player.footprint_log[i].alpha = 1 - (time_diff / player.footprint_decay)
		
		if (time_diff > player.footprint_decay) {
			player.footprint_log.splice(i, 1)
		}
	}
	/*
	if (player.footprint_log.length > player.max_footprints) {
		player.footprint_log.shift()
	}
	
	// adjust footprint transparencies
	for (let i=0; i<player.footprint_log.length; i++) {
		player.footprint_log[i].alpha = (i + 1) / player.footprint_log.length
	}
	*/
	
	// Check if we have to draw a new footprint
	if (getDistance(player.x, player.y, player.last_x_drawn, player.last_y_drawn) > player.stride) {
		player.draw_foot()
		player.last_x_drawn = player.x
		player.last_y_drawn = player.y
	}
	
}


function draw() {
	// clear the screen
	//context.clearRect(0, 0, canvas.width, canvas.height)
	context.fillStyle = context.createPattern(background_img, 'repeat')
	context.fillRect(0, 0, canvas.width, canvas.height);
	
	// Iterate through the draw log and sends each one out to draw
	for (item of player.footprint_log) {
		draw_image(item.x, item.y, item.angle, item.image, item.image_width, item.image_height, item.alpha)
	}
	
	// draw the player
	//player.draw_line()
	
}

function loop(timestamp) {
	var progress = timestamp - lastRender
	
	update()
	draw()
	
	lastRender = timestamp
	window.requestAnimationFrame(loop)
}

var lastRender = 0
window.requestAnimationFrame(loop)

</script>
</html>